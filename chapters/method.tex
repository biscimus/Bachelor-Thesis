\section{Framework Overview}
In order to look deeper into the main problem of this thesis, we first formally define our problem as described below.

\begin{definition}[Translucent Log Extension Problem]
\label{def:tlgp}
    Given an event log $\mathcal{L}$ as input, produce a translucent event log $\mathcal{L'}$ where the set of enabled activities are added as attributes. 
\end{definition}

There is a variant of the \emph{Translucent Log Extension Problem}, where a process model is provided along with the event log.

\begin{definition}[Translucent Log Extension Problem - Process Model Variant]
\label{def:tlgpm}
    Given an event log $\mathcal{L}$ and a process model $\mathcal{M}$ as inputs, produce a translucent event log $\mathcal{L'}$ where the set of enabled activities are added as attributes. 
\end{definition}

The second variant differs from the first, as the model is meant to act as a reference model; the set of enabled activities is intended to be constrained by the process model. Note that the function of $\mathcal{M}$ is to provide an upper bound on the set of enabled activities, and the log is there to provide further constraints to enrich the model. Of particular interest are parallel and choice situations, since we are able to deduce supplementary patterns not demonstrated in the process model using log data. We name the first variant defined in Definition \ref{def:tlgp} as \emph{Bottom-up Translucent Log Extension Problem}, whereas the second variant in Definition \ref{def:tlgpm} is named as \emph{Top-down Translucent Log Extension Problem.}

\section{Top-down Approaches}

\subsection{Petri Net-based Approaches}

The basic notion of Petri nets was introduced in the previous chapter. \dots

Given a Petri net and an event log, the program utiltizes the alignment-based appraoch presented in \cite{creating-translucent-event-logs} as its baseline algorithm. After computing the alignment for each trace, the program replays the alignment on the reachabiliy graph trace by trace in order to circumvent the silent transitions. For each activity, the algorithm then augments the event log with the corresponding transitions situated in outgoing arcs of the current state. After creating a basic translucent event log, the log can be refined by further algorithms.

\dots

When annotating the event log with enabled activities, it might make sense to assume that not all activities enabled in the model are enabled in reality. The model might be too permissive to guarantee its fitness to the event log, and the set of enabled activities depicted in the model should therefore be considered as an upper bound of the actual set. Here, instead of applying a hard-line policy by adding guards to the transitions as done in the field of decision mining, we can utilize a probabilistic approach to filter out the activities. An important question would be how we should compute the transition probability of the model. This is where the PLDPN model comes into play.

A method to incorporate the data attributes is to implement multivariate regression. Similar to the setting in \cite{sldpn}, we construct a training data set for each transition of a Petri net consisting of data attributes and a boolean label indicating whether the transition was executed given the data attributes as input. We then perform a regression analysis on the training data set for each transition. The resulting dictionary of transitions and regression functions can be employed to filter out transitions lying below a certain probability threshold $p$ in each decision point during replay.

\textcolor{red}{The method how to construct an SLDPN is already introduced in Christopher's paper. Should I repeat them here, or should I just refer to the paper? I think it would be better for the reader to repeat them here, but does it count as plagiarism?}



\subsection{Transition System-based Approaches}

... One of the advantages of utilizing transition systems over Petri nets is the lack of silent transitions. When trying to replay a trace on a Petri net in the presence of silent transition, the algorithm must decide which path of the firing sequence it should take by computing alignments with a certain cost function, then taking the path with the minimal cost. This can be computationally expensive and time-consuming, especially for larger models where the number of silent transitions is high. Transition systems can benefit us in this regard.

\begin{definition}[Frequency-Annotated Prefix Automaton]
    Let $\mathcal{L}$ be a simple event log. A \emph{Frequency-Annotated Prefix Automaton (FAPA)} is a tuple $PA_{freq} = (S, A, T, f)$, where $(S, A, T)$ is a prefix automaton $TS_{L, hd}$ following the definition \ref{def:pa} and  $f: S \to \mathbb{N}, \sigma_{pref} \mapsto \lvert \{ \sigma \in \mathcal{L} \mid \sigma_{pref} \sqsubseteq \sigma \}\rvert$ is a frequency labeling function.
\end{definition}

Let us look at a small example. Consider the simple event log $\mathcal{L} = [\langle a, b, c \rangle^{30}, \langle a, b, d \rangle^{10}]$. In order to generate an FAPA from $\mathcal{L}$, we can use the following algorithm:

\begin{algorithm}
\caption[short]{FAPA Generation}
    \For{$\sigma \in \mathcal{L}$}
    {
        \For{$i \in \lvert \sigma \rvert$}
        {
            $\sigma_{pref} \gets hd_i(\sigma)$\;
            $f(\sigma) \gets f(\sigma) + 1$\;
        }
    }
\end{algorithm}

The resulting FAPA is depicted in \ref{fig:fapa}. The frequency labeling function $f$ is represented as in the usual superscript notation used in trace multiset of simple event logs.

\begin{figure}
    \centering
    \begin{tikzpicture}[auto, node distance=3cm, 
        every node/.style={draw, ellipse, font=\sffamily\large\bfseries, inner sep=1pt, outer sep=0pt, minimum height=1cm},
        every edge/.style={draw, -{Stealth[]}, thick}]

        \node (1) {$<>^{40}$};
        \node (2) [right of=1] {$<a>^{40}$};
        \node (3) [right of=2] {$<a, b>^{40}$};
        \node (4) [above right of=3] {$<a, b, c>^{30}$};
        \node (5) [below right of=3] {$<a, b, d>^{10}$};

        \path[every node/.style={font=\sffamily\small}]
        (1) edge node {a} (2)
        (2) edge node {b} (3)
        (3) edge node {c} (4)
        edge node {d} (5);
    \end{tikzpicture}
    \caption{Resulting FAPA from $\mathcal{L}$.}
    \label{fig:fapa}
\end{figure}

Given a certain threshold, a simple algorithm would be to iterate over each trace in the event log and annotating the enabled activities with transitions lying above the threshold. For a threshold value of e.g. $t = 0.5$, the resulting simple translucent event log would be: $[\langle \underline{a}, \underline{b}, \underline{c} \rangle^{30}, \langle \underline{a}, \underline{b}, c\underline{d}\rangle^{10}]$. Note that annotating enabled activites using conventional prefix automata can be considered as a special case of this problem with threshold $t = 0$.









\section{Bottom-up Approaches}

\begin{itemize}
    \item Given an event log, we compute the set of unique activities and generate a next-activity matrix $\mathcal{A}$, where the entry $\mathcal{A}_{ij}$ represents the number of times activity $j$ follows activity $i$. We can then easily transform $\mathcal{A}$ into a probability matrix $\mathcal{A'}$ by dividing each row by the sum of the row. We then filter out the results by a certain threshold $p$ and add the entries surviving the threshold to each event trace. This algorithm can serve as baseline for further extensions.
    \item Furthermore, we can utilitze a deep-learning based black-box approach. The issue with implementing supervised learning algorithms is that we need a labeled training dataset. In our case, this would be a preexisting translucent event log, which is unavailable in our setting due to missing enabled activities data. We can cirucmvent the problem by training the model using the next activity information as label, as this information is available in every event log. Since most learning algorithms would not return a single value but an underlying probability distribution of possible outcomes, we can substitute the final $\mathit{argmax}$ operation with selecting a threshold $p$ and returning all labels lying above it.
\end{itemize}

Note that this is not the final list as we are still in the process of selecting new methods. The final list of methods will be updated in the final version of the thesis paper.



